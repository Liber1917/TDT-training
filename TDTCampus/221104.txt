#include <stdio.h>
#include "stm32f10x.h"
#include "stm32f10x_gpio.h"
#include "sys.h"


#define LB GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11)
#define LMB GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)
#define RMB GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9)
#define RB GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8)

int direction;
/**********************Sensor initialization**************************/
void cgq(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	//  GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;

	GPIO_Init(GPIOA, &GPIO_InitStructure);

}
/*************************moter initialization*****************************/
void MOTER_Init1(void)
{
	GPIO_InitTypeDef GPIO_IS1;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

	GPIO_IS1.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_IS1.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_6;
	GPIO_IS1.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_Init(GPIOB, &GPIO_IS1);
}

void MOTER_Init2(void)//for shooter
{
	GPIO_InitTypeDef GPIO_IS1;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

	GPIO_IS1.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_IS1.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
	GPIO_IS1.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_Init(GPIOB, &GPIO_IS1);
}
/*************************loader initialization**********************************/
void Load_Init(void)//for load&reload
{
	GPIO_InitTypeDef GPIO_IS1;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

	GPIO_IS1.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_IS1.GPIO_Pin = GPIO_Pin_6;
	GPIO_IS1.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_Init(GPIOA, &GPIO_IS1);
}

/*************************lever initialization**********************************/
void Lever_Init(void)//for load&reload
{
	GPIO_InitTypeDef GPIO_IS1;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

	GPIO_IS1.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_IS1.GPIO_Pin = GPIO_Pin_7;
	GPIO_IS1.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_Init(GPIOA, &GPIO_IS1);
}
/************************PWM initialization*********************************/
void PWM_Init1(u16 arr, u16 psc)//PWM for moters
{
	TIM_TimeBaseInitTypeDef TIM_TBS1;
	TIM_OCInitTypeDef TIM_OCIS1;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);

	MOTER_Init1();

	TIM_DeInit(TIM4);

	TIM_TBS1.TIM_Period = arr;
	TIM_TBS1.TIM_ClockDivision = 0;
	TIM_TBS1.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TBS1.TIM_Prescaler = psc;
	TIM_TBS1.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM4, &TIM_TBS1);

	TIM_OCIS1.TIM_OCMode = TIM_OCMode_PWM2;
	TIM_OCIS1.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCIS1.TIM_Pulse = 0;
	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_Low;
	//	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_High ;
	TIM_OC1Init(TIM4, &TIM_OCIS1);//B6
	TIM_OC2Init(TIM4, &TIM_OCIS1);//B7
	TIM_OC3Init(TIM4, &TIM_OCIS1);//B8
	TIM_OC4Init(TIM4, &TIM_OCIS1);//B9

	TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
	TIM_OC2PreloadConfig(TIM4, TIM_OCPreload_Enable);
	TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Enable);
	TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Enable);

	TIM_Cmd(TIM4, ENABLE);
}
void PWM_Init2(u16 arr, u16 psc)//PWM for shooter
{
	TIM_TimeBaseInitTypeDef TIM_TBS1;
	TIM_OCInitTypeDef TIM_OCIS1;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);

	MOTER_Init2();

	TIM_DeInit(TIM3);

	TIM_TBS1.TIM_Period = arr;
	TIM_TBS1.TIM_ClockDivision = 0;
	TIM_TBS1.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TBS1.TIM_Prescaler = psc;
	TIM_TBS1.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM3, &TIM_TBS1);

	TIM_OCIS1.TIM_OCMode = TIM_OCMode_PWM2;
	TIM_OCIS1.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCIS1.TIM_Pulse = 0;
	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_Low;
	//	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_High ;

	TIM_OC3Init(TIM3, &TIM_OCIS1);//B0
	TIM_OC4Init(TIM3, &TIM_OCIS1);//B1



	TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Enable);
	TIM_OC4PreloadConfig(TIM3, TIM_OCPreload_Enable);

	TIM_Cmd(TIM3, ENABLE);
}

void PWM_Init3(u16 arr, u16 psc)//PWM for loader
{
	TIM_TimeBaseInitTypeDef TIM_TBS1;
	TIM_OCInitTypeDef TIM_OCIS1;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);

	MOTER_Init2();

	TIM_DeInit(TIM3);

	TIM_TBS1.TIM_Period = arr;
	TIM_TBS1.TIM_ClockDivision = 0;
	TIM_TBS1.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TBS1.TIM_Prescaler = psc;
	TIM_TBS1.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM3, &TIM_TBS1);

	TIM_OCIS1.TIM_OCMode = TIM_OCMode_PWM2;
	TIM_OCIS1.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCIS1.TIM_Pulse = 0;
	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_Low;
	//	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_High ;

	TIM_OC1Init(TIM3, &TIM_OCIS1);//A6
	TIM_OC2Init(TIM3, &TIM_OCIS1);//A7



	TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);
	TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);


	TIM_Cmd(TIM3, ENABLE);
}

void PWM_Init4(u16 arr, u16 psc)//PWM for lever
{
	TIM_TimeBaseInitTypeDef TIM_TBS1;
	TIM_OCInitTypeDef TIM_OCIS1;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

	MOTER_Init2();

	TIM_DeInit(TIM2);

	TIM_TBS1.TIM_Period = arr;
	TIM_TBS1.TIM_ClockDivision = 0;
	TIM_TBS1.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TBS1.TIM_Prescaler = psc;
	TIM_TBS1.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM2, &TIM_TBS1);

	TIM_OCIS1.TIM_OCMode = TIM_OCMode_PWM2;
	TIM_OCIS1.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCIS1.TIM_Pulse = 0;
	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_Low;
	//	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_High ;

	TIM_OC1Init(TIM2, &TIM_OCIS1);//A0
	TIM_OC2Init(TIM2, &TIM_OCIS1);//A1



	TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);
	TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);

	TIM_Cmd(TIM2, ENABLE);
}
/********************parameters of motors************************/
void mt(u16 a, u16 b, u16 c, u16 d, u16 t)
{
	/****Switch to Pull mode****/
/*parameters of R mt1*/
	TIM_SetCompare4(TIM4, a);//Back
	TIM_SetCompare3(TIM4, b);//Forward
	/*parameters of L mt2*/
	TIM_SetCompare2(TIM4, c);//Back
	TIM_SetCompare1(TIM4, d);//Forward
	for (u16 i = 1; i <= t; i++)//senser delay
	{
		delay_ms(1);
	}
	TIM_SetCompare4(TIM4, 0);
	TIM_SetCompare3(TIM4, 0);
	TIM_SetCompare1(TIM4, 0);
	TIM_SetCompare2(TIM4, 0);
}

void mt1(u16 a, u16 b, u16 t)//for shooter
{
	/****Switch to Pull mode****/

	TIM_SetCompare1(TIM3, a);//Back
	TIM_SetCompare2(TIM3, b);//Forward

	for (u16 i = 1; i <= t; i++)//senser delay
	{
		delay_ms(1);
	}

	TIM_SetCompare1(TIM3, 0);
	TIM_SetCompare2(TIM3, 0);
}



void lv(u16 a, u16 b,u16 t)//for lever
{
	/****Switch to Pull mode****/

	TIM_SetCompare1(TIM2, a);//Back
	TIM_SetCompare1(TIM2, b);//Forward
	for (u16 i = 1; i <= t; i++)//senser delay
	{
		delay_ms(1);
	}
	TIM_SetCompare1(TIM2, 0);
	TIM_SetCompare2(TIM2, 0);
}








int main(void)
{
	delay_init();
	PWM_Init1(199, 219);//PWM Setting
	PWM_Init2(199, 219);//PWM Setting
	PWM_Init3(199, 219);//PWM Setting
	PWM_Init4(199, 219);//PWM Setting
	cgq();
	

/*******************************START**********************************/	
	
	
						/***********************forward********************************************/

				mt(15,150,14,150,2000);//yet to be vertified
	delay_ms (100);

				/***********************back********************************************/

				mt(120,15,120,15,2200);//vertified
		delay_ms (100);

				/******************************** rotation from right side****************************/
				direction=2;
//				do
//				{
					mt(150,45,45,150,1400);//vertified for 180
			delay_ms(100);
//				} while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));

/************************************************************/
		while (1)
	{
				if (!LB && LMB && !RMB && !RB)
				{//mid left black
					do
					{
						/*go left*/
					direction=1;

							mt(25,150,50,150,1);//yet to be vertified

					} while (LMB);
				}
				else if (!LB && !LMB && RMB && !RB)
				{//mid right black
					do
					{
						//go right
						direction=2;
						mt(50,150,25,150,1);

					}while(RMB);
				}
				else if (!LB && LMB && RMB && !RB)
				{//mid black

						//go forward
						direction=0;
						mt(50,150,50,150,1);

				}
				else if (!LB && !LMB && !RMB && RB)
				{//right black
					do
					{
						/*Right  rotation*/
						direction=2;
			mt(150,80,25,150,1);//Yet to be vertified

					} while (!LMB);
/*left  rotation*/
			mt(25,150,80,150,2);//Yet to be vertified
				}
				else if (LB && !LMB && !RMB && !RB)
				{//left black
					do
					{
						/*left  rotation*/
						direction=1;
			mt(25,150,150,80,1);//Yet to be vertified

					} while (!RMB);
						/*Right  rotation*/
			mt(80,150,25,150,2);//Yet to be vertified
				}
				else if (LB && !LMB && !RMB && RB)
				{//dimond
					do
					{
						/*left  rotation??????*/
						direction=1;
			mt(25,150,150,80,10);//Yet to be vertified

					} while (!RMB);
				}
				else if (LB && !LMB && RMB && !RB)
				{//A10A8,white
					do
					{
						/*right  rotation*/
						direction=2;
			mt(150,80,25,150,1);//Yet to be vertified

					} while (RMB);
				}
				else if (!LB && LMB && !RMB && RB)
				{//A11A9,white 
					do
					{
						/*left  rotation*/
						direction=1;
			mt(25,150,150,80,1);//Yet to be vertified

					} while (LMB);
				}
				else if (LB && LMB && !RMB && !RB)
				{//2left black
					do
					{
						/*left  rotation*/
						direction=1;
			mt(25,150,150,80,1);//Yet to be vertified

					} while (!RMB);
				}
				else if (!LB && !LMB && RMB && RB)
				{//2right black
					do
					{
						/*right  rotation*/
						direction=2;
			mt(150,80,25,150,1);//Yet to be vertified

					} while (!LMB);
				}
				else if (!LB && LMB && RMB && RB)
				{//3right black
													/************************************shoot**********************/
//				mt1(100, 30, 200);//need to measure
					
					
					
//					do
//					{
						/*right  rotation*/
						direction=2;
			mt(150,50,25,150,30);//Yet to be vertified

//					} while (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) );
				}
				else if (LB && LMB && RMB && !RB)
				{//3left black
													/************************************shoot**********************/
//				mt1(100, 30, 200);//need to measure
					
					
					
//					do
//					{
						/*left  rotation*/
						direction=1;
			mt(25,150,150,50,30);//Yet to be vertified

//					} while (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) );
				}
				else if (LB && !LMB && RMB && RB)
				{//mid left white
					
					
					
					
					do
					{
						/*right  rotation*/
						direction=2;
			mt(150,70,55,150,1);//Yet to be vertified

					} while (!LMB);
				}
				else if (LB && LMB && !RMB && RB)
				{//mid right white
					
					
					
					
					do
					{
						/*left  rotation*/
						direction=1;
			mt(55,150,150,70,1);//Yet to be vertified

					} while (!RMB);
				}
				 
				else if (LB && LMB && RMB && RB)
				{//meet "T"
// 			delay_ms(100);
			/********************************yet to be vertified*************************/
				/**********************to stop maybe need to back for a short time****************/
				/*Stop for n second*/
//				mt(0, 0, 0, 0, 10);//vet to be vertified



					/***********************forward********************************************/

				mt(15,150,14,150,2000);//yet to be vertified

				/***********************back********************************************/

				mt(120,15,120,14,2200);//vertified





				/******************************** rotation from right side****************************/
				direction=1;
//				do
//				{
					mt(150,45,45,150,1400);//vertified for 180
			delay_ms(100);
//				} while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
			
				

					
					
					
					do
					{
						/*left  rotation*/
						direction=1;
			mt(5,150,30,150,7);//Yet to be vertified

					} while (!LMB&& !RMB);
				}
				
				else if (!LB && !LMB && !RMB && !RB)
				{//all white

					if(direction==1)
					{
//					do
//					{
						//go right
						direction=2;
						mt(70,150,55,150,1);

//					}while(!LMB||!RMB);
				}
					else if(direction==2)
					{
//					do
//					{
						//go left
						direction=1;
						mt(55,150,70,150,1);

//					}while(!LMB||!RMB);
				}
			}
				
				
				
		}
	}