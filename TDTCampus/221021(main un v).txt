#include <stdio.h>
#include "stm32f10x.h"
#include "stm32f10x_gpio.h"
#include "sys.h"
/**********************Sensor initialization**************************/
void cgq(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	//  GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;

	GPIO_Init(GPIOA, &GPIO_InitStructure);

}
/*************************moter initialization*****************************/
void MOTER_Init1(void)
{
	GPIO_InitTypeDef GPIO_IS1;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

	GPIO_IS1.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_IS1.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_6;
	GPIO_IS1.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_Init(GPIOB, &GPIO_IS1);
}

void MOTER_Init2(void)//for shooter
{
	GPIO_InitTypeDef GPIO_IS1;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

	GPIO_IS1.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_IS1.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
	GPIO_IS1.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_Init(GPIOB, &GPIO_IS1);
}
/*************************loader initialization**********************************/
void Load_Init(void)//for load&reload
{
	GPIO_InitTypeDef GPIO_IS1;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

	GPIO_IS1.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_IS1.GPIO_Pin = GPIO_Pin_2;//9g-->A2
	GPIO_IS1.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_Init(GPIOA, &GPIO_IS1);
}

/*************************lever initialization**********************************/
void Lever_Init(void)//for lever
{
	GPIO_InitTypeDef GPIO_IS1;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

	GPIO_IS1.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_IS1.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_6;//tt-->A6A7
	GPIO_IS1.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_Init(GPIOA, &GPIO_IS1);
}
/************************PWM initialization*********************************/
void PWM_Init1(u16 arr, u16 psc)//PWM for moters
{
	TIM_TimeBaseInitTypeDef TIM_TBS1;
	TIM_OCInitTypeDef TIM_OCIS1;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);

	MOTER_Init1();

	TIM_DeInit(TIM4);

	TIM_TBS1.TIM_Period = arr;
	TIM_TBS1.TIM_ClockDivision = 0;
	TIM_TBS1.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TBS1.TIM_Prescaler = psc;
	TIM_TBS1.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM4, &TIM_TBS1);

	TIM_OCIS1.TIM_OCMode = TIM_OCMode_PWM2;
	TIM_OCIS1.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCIS1.TIM_Pulse = 0;
	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_Low;
	//	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_High ;
	TIM_OC1Init(TIM4, &TIM_OCIS1);//B6
	TIM_OC2Init(TIM4, &TIM_OCIS1);//B7
	TIM_OC3Init(TIM4, &TIM_OCIS1);//B8
	TIM_OC4Init(TIM4, &TIM_OCIS1);//B9

	TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
	TIM_OC2PreloadConfig(TIM4, TIM_OCPreload_Enable);
	TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Enable);
	TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Enable);

	TIM_Cmd(TIM4, ENABLE);
}
void PWM_Init2(u16 arr, u16 psc)//PWM for shooter
{
	TIM_TimeBaseInitTypeDef TIM_TBS1;
	TIM_OCInitTypeDef TIM_OCIS1;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);

	MOTER_Init2();

	TIM_DeInit(TIM3);

	TIM_TBS1.TIM_Period = arr;
	TIM_TBS1.TIM_ClockDivision = 0;
	TIM_TBS1.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TBS1.TIM_Prescaler = psc;
	TIM_TBS1.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM3, &TIM_TBS1);

	TIM_OCIS1.TIM_OCMode = TIM_OCMode_PWM2;
	TIM_OCIS1.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCIS1.TIM_Pulse = 0;
	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_Low;
	//	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_High ;

	TIM_OC3Init(TIM3, &TIM_OCIS1);//B0
	TIM_OC4Init(TIM3, &TIM_OCIS1);//B1



	TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Enable);
	TIM_OC4PreloadConfig(TIM3, TIM_OCPreload_Enable);

	TIM_Cmd(TIM3, ENABLE);
}

void PWM_Init3(u16 arr, u16 psc)//PWM for loader
{
	TIM_TimeBaseInitTypeDef TIM_TBS1;
	TIM_OCInitTypeDef TIM_OCIS1;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

	MOTER_Init2();

	TIM_DeInit(TIM2);

	TIM_TBS1.TIM_Period = arr;
	TIM_TBS1.TIM_ClockDivision = 0;
	TIM_TBS1.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TBS1.TIM_Prescaler = psc;
	TIM_TBS1.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM3, &TIM_TBS1);

	TIM_OCIS1.TIM_OCMode = TIM_OCMode_PWM2;
	TIM_OCIS1.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCIS1.TIM_Pulse = 0;
	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_Low;
	//	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_High ;

	TIM_OC3Init(TIM2, &TIM_OCIS1);//A2




	TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);


	TIM_Cmd(TIM2, ENABLE);
}

void PWM_Init4(u16 arr, u16 psc)//PWM for lever
{
	TIM_TimeBaseInitTypeDef TIM_TBS1;
	TIM_OCInitTypeDef TIM_OCIS1;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);

	MOTER_Init2();

	TIM_DeInit(TIM3);

	TIM_TBS1.TIM_Period = arr;
	TIM_TBS1.TIM_ClockDivision = 0;
	TIM_TBS1.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TBS1.TIM_Prescaler = psc;
	TIM_TBS1.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM3, &TIM_TBS1);

	TIM_OCIS1.TIM_OCMode = TIM_OCMode_PWM2;
	TIM_OCIS1.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCIS1.TIM_Pulse = 0;
	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_Low;
	//	TIM_OCIS1.TIM_OCPolarity = TIM_OCPolarity_High ;
	TIM_OC1Init(TIM3, &TIM_OCIS1);//A6
	TIM_OC2Init(TIM3, &TIM_OCIS1);//A7




	TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);


	TIM_Cmd(TIM3, ENABLE);
}
/********************parameters of motors************************/
void mt(u16 a, u16 b, u16 c, u16 d, u16 t)
{
	/****Switch to Pull mode****/
/*parameters of R mt1*/
	TIM_SetCompare4(TIM4, a);//Back
	TIM_SetCompare3(TIM4, b);//Forward
	/*parameters of L mt2*/
	TIM_SetCompare2(TIM4, c);//Back
	TIM_SetCompare1(TIM4, d);//Forward
	for (u16 i = 1; i <= t; i++)//senser delay
	{
		delay_ms(10);
	}
	TIM_SetCompare4(TIM4, 0);
	TIM_SetCompare3(TIM4, 0);
	TIM_SetCompare1(TIM4, 0);
	TIM_SetCompare2(TIM4, 0);
}

void mt1(u16 a, u16 b, u16 t)//for shooter
{
	/****Switch to Pull mode****/

	TIM_SetCompare1(TIM3, a);//Back
	TIM_SetCompare2(TIM3, b);//Forward

	for (u16 i = 1; i <= t; i++)//senser delay
	{
		delay_ms(10);
	}

	TIM_SetCompare1(TIM4, 0);
	TIM_SetCompare2(TIM4, 0);
}

void lv(u16 a, u16 b,u16 t)
{
	/****Switch to Pull mode****/
/*parameters of R mt1*/
	TIM_SetCompare4(TIM4, a);//Back
	TIM_SetCompare3(TIM4, b);//Forward
	for (u16 i = 1; i <= t; i++)//senser delay
	{
		delay_ms(10);
	}
	TIM_SetCompare4(TIM4, 0);
	TIM_SetCompare3(TIM4, 0);
}
/*******main function********/
//int main(void)
//{
//    delay_init();
//    PWM_Init1(199,7199) ;//PWM Setting
//		PWM_Init2(199,7199) ;//PWM Setting
//		
//	cgq();

//	while(1)
//	{
//		
//	/**All White*/

//			/*Right self rotation*/
//			mt(120,90,90,120,3);//Yet to be vertified
//			break;


// }
//}	
int main(void)
{
	delay_init();
	PWM_Init1(199, 7199);//PWM Setting
	PWM_Init2(199, 7199);//PWM Setting
	PWM_Init3(199, 7199);//PWM Setting
	PWM_Init4(199, 7199);//PWM Setting
	cgq();

	while (1)
	{

		/**All White*/
		if (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11))
		{
			/*Left rotation*/
			mt(70, 130, 90, 110, 10);//Yet to be vertified

		}
		else
		{

			/*All Black yet to be vertified*/
			if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))
			{
				/********************************yet to be vertified*************************/
				/**********************to stop maybe need to back for a short time****************/
				mt(30, 0, 30, 0, 100);//yet to be vertified
				/*Stop for n second*/
				mt(0, 0, 0, 0, 100);//vet to be vertified
				/***********************back********************************************/

				mt(40, 0, 40, 0, 100);//yet to be vertified



				/************************************shoot**********************/
				mt1(100, 30, 200);//need to measure
				/******************************** rotation from right side****************************/
				do
				{
					mt(0, 0, 30, 100, 30);
				} while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
			}
			else if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) + GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) + GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) + GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8) == 3)
			{
				/**********************************************3***************************************/
				if (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))
				{//except left side all black
					/*******************************stop*************************/
					mt(30, 0, 30, 0, 50);
					/**********************************right rotation*******************/
					do
					{
						mt(0, 0, 70, 100, 30);
					} while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
				}
				else if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))
				{//except right side all black
					/********************************stop******************************/
					mt(30, 0, 30, 0, 50);
					/**********************************left rotation*****************/
					do
					{
						mt(70, 100, 0, 0, 30);
					} while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
				}
				/*Middle space yet to be adjusted*/
				else if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))//Middle Right White
				{
					/*Go Left*/
					do
						mt(70, 100, 0, 0, 4);//Yet to be vertified
					while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
				}
				else if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))//Middle Left White
				{
					/*Go Right*/
					do
						mt(0, 0, 70, 100, 4);//Yet to be vertified
					while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
				}
			}
			else if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) + GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) + GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) + GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8) == 2)
			{
				if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10))//Side Black&&Middle White			
				{//Side Black&&Middle White
					do
					{
						/**************************** right rotation for 45 degree(if don't want to get the middle mine)*********************************/
						/*Stop*/
						mt(0, 0, 0, 0, 30);//Yet to be vertified
						/*Right rotation*/

						mt(0, 0, 70, 100, 4);//Yet to be vertified

					}

					while (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9));//Middle Right
				}
				else if (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))
				{//middle black and side white
					do
						mt(30, 100, 30, 100, 20);
					while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));

				}
				else if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))
				{//mid left and right black
					do
						mt(70, 100, 0, 0, 30);
					while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
				}
				else if (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))
				{//mid right and left black
					do
						mt(0, 0, 70, 100, 50);
					while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
				}
				else if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))
				{//left and mid left black

					do
						mt(0, 0, 70, 100, 30);
					while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
				}
				else if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))
				{
					do
						mt(70, 100, 0, 0, 30);
					while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
				}
			}
			else if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) + GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) + GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) + GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8) == 1)
			{

				if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))//Left Side Black
				{//Left Side Black
					do
					{
						/*Left rotation*/
						mt(70, 100, 0, 0, 4);//Yet to be vertified
					} while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));//Middle Right
				}
				else if (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))//Right Side Black
				{//right side black
					do
					{
						/*Right rotation*/
						mt(0, 0, 70, 100, 4);//Yet to be vertified
					} while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
				}
				else if (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))
				{//mid left black
					do
					{
						/*left rotation*/
						do
							mt(70, 100, 0, 0, 30);//yet to be vertified
						while (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8));
					} while (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10));//?
				}
				else if (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) && !GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8))
				{//mid right black
					do
					{
						//right rotation
						mt(0, 0, 70, 100, 30);
					} while (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9));//?
				}
				//					else if(GPIO_ReadInputDataBit (GPIOA,GPIO_Pin_10)&&GPIO_ReadInputDataBit (GPIOA,GPIO_Pin_9))//Middle Black
				//						{
				//							mt(80,120,80,120,10);//Yet to be vertified
				//						}
			}
		}

	}
}
